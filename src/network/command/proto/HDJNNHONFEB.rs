// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `HDJNNHONFEB.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:HDJNNHONFEB)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HDJNNHONFEB {
    // message fields
    // @@protoc_insertion_point(field:HDJNNHONFEB.FCHMCFNFJJO)
    pub FCHMCFNFJJO: u32,
    // message oneof groups
    pub CPNPDEJFCDN: ::std::option::Option<hdjnnhonfeb::CPNPDEJFCDN>,
    // special fields
    // @@protoc_insertion_point(special_field:HDJNNHONFEB.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HDJNNHONFEB {
    fn default() -> &'a HDJNNHONFEB {
        <HDJNNHONFEB as ::protobuf::Message>::default_instance()
    }
}

impl HDJNNHONFEB {
    pub fn new() -> HDJNNHONFEB {
        ::std::default::Default::default()
    }

    // .EMKEHPGJBGN BCJJKDGBFFN = 11;

    pub fn BCJJKDGBFFN(&self) -> &super::EMKEHPGJBGN::EMKEHPGJBGN {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(ref v)) => v,
            _ => <super::EMKEHPGJBGN::EMKEHPGJBGN as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_BCJJKDGBFFN(&mut self) {
        self.CPNPDEJFCDN = ::std::option::Option::None;
    }

    pub fn has_BCJJKDGBFFN(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_BCJJKDGBFFN(&mut self, v: super::EMKEHPGJBGN::EMKEHPGJBGN) {
        self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(v))
    }

    // Mutable pointer to the field.
    pub fn mut_BCJJKDGBFFN(&mut self) -> &mut super::EMKEHPGJBGN::EMKEHPGJBGN {
        if let ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(_)) = self.CPNPDEJFCDN {
        } else {
            self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(super::EMKEHPGJBGN::EMKEHPGJBGN::new()));
        }
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_BCJJKDGBFFN(&mut self) -> super::EMKEHPGJBGN::EMKEHPGJBGN {
        if self.has_BCJJKDGBFFN() {
            match self.CPNPDEJFCDN.take() {
                ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(v)) => v,
                _ => panic!(),
            }
        } else {
            super::EMKEHPGJBGN::EMKEHPGJBGN::new()
        }
    }

    // .HEDFBLJLMNK FLFGFGKNMHF = 5;

    pub fn FLFGFGKNMHF(&self) -> &super::HEDFBLJLMNK::HEDFBLJLMNK {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(ref v)) => v,
            _ => <super::HEDFBLJLMNK::HEDFBLJLMNK as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_FLFGFGKNMHF(&mut self) {
        self.CPNPDEJFCDN = ::std::option::Option::None;
    }

    pub fn has_FLFGFGKNMHF(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FLFGFGKNMHF(&mut self, v: super::HEDFBLJLMNK::HEDFBLJLMNK) {
        self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_FLFGFGKNMHF(&mut self) -> &mut super::HEDFBLJLMNK::HEDFBLJLMNK {
        if let ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(_)) = self.CPNPDEJFCDN {
        } else {
            self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(super::HEDFBLJLMNK::HEDFBLJLMNK::new()));
        }
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_FLFGFGKNMHF(&mut self) -> super::HEDFBLJLMNK::HEDFBLJLMNK {
        if self.has_FLFGFGKNMHF() {
            match self.CPNPDEJFCDN.take() {
                ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(v)) => v,
                _ => panic!(),
            }
        } else {
            super::HEDFBLJLMNK::HEDFBLJLMNK::new()
        }
    }

    // .MDCDEFONBLB CADHAOEMMIC = 12;

    pub fn CADHAOEMMIC(&self) -> &super::MDCDEFONBLB::MDCDEFONBLB {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(ref v)) => v,
            _ => <super::MDCDEFONBLB::MDCDEFONBLB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_CADHAOEMMIC(&mut self) {
        self.CPNPDEJFCDN = ::std::option::Option::None;
    }

    pub fn has_CADHAOEMMIC(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_CADHAOEMMIC(&mut self, v: super::MDCDEFONBLB::MDCDEFONBLB) {
        self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(v))
    }

    // Mutable pointer to the field.
    pub fn mut_CADHAOEMMIC(&mut self) -> &mut super::MDCDEFONBLB::MDCDEFONBLB {
        if let ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(_)) = self.CPNPDEJFCDN {
        } else {
            self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(super::MDCDEFONBLB::MDCDEFONBLB::new()));
        }
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_CADHAOEMMIC(&mut self) -> super::MDCDEFONBLB::MDCDEFONBLB {
        if self.has_CADHAOEMMIC() {
            match self.CPNPDEJFCDN.take() {
                ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(v)) => v,
                _ => panic!(),
            }
        } else {
            super::MDCDEFONBLB::MDCDEFONBLB::new()
        }
    }

    // .GKKPEJMKPJB EIICOHEMHCA = 1;

    pub fn EIICOHEMHCA(&self) -> &super::GKKPEJMKPJB::GKKPEJMKPJB {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(ref v)) => v,
            _ => <super::GKKPEJMKPJB::GKKPEJMKPJB as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EIICOHEMHCA(&mut self) {
        self.CPNPDEJFCDN = ::std::option::Option::None;
    }

    pub fn has_EIICOHEMHCA(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EIICOHEMHCA(&mut self, v: super::GKKPEJMKPJB::GKKPEJMKPJB) {
        self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EIICOHEMHCA(&mut self) -> &mut super::GKKPEJMKPJB::GKKPEJMKPJB {
        if let ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(_)) = self.CPNPDEJFCDN {
        } else {
            self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(super::GKKPEJMKPJB::GKKPEJMKPJB::new()));
        }
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EIICOHEMHCA(&mut self) -> super::GKKPEJMKPJB::GKKPEJMKPJB {
        if self.has_EIICOHEMHCA() {
            match self.CPNPDEJFCDN.take() {
                ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GKKPEJMKPJB::GKKPEJMKPJB::new()
        }
    }

    // .JKLIHAMFKDP INJCENAIEHM = 8;

    pub fn INJCENAIEHM(&self) -> &super::JKLIHAMFKDP::JKLIHAMFKDP {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(ref v)) => v,
            _ => <super::JKLIHAMFKDP::JKLIHAMFKDP as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_INJCENAIEHM(&mut self) {
        self.CPNPDEJFCDN = ::std::option::Option::None;
    }

    pub fn has_INJCENAIEHM(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_INJCENAIEHM(&mut self, v: super::JKLIHAMFKDP::JKLIHAMFKDP) {
        self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(v))
    }

    // Mutable pointer to the field.
    pub fn mut_INJCENAIEHM(&mut self) -> &mut super::JKLIHAMFKDP::JKLIHAMFKDP {
        if let ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(_)) = self.CPNPDEJFCDN {
        } else {
            self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(super::JKLIHAMFKDP::JKLIHAMFKDP::new()));
        }
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_INJCENAIEHM(&mut self) -> super::JKLIHAMFKDP::JKLIHAMFKDP {
        if self.has_INJCENAIEHM() {
            match self.CPNPDEJFCDN.take() {
                ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(v)) => v,
                _ => panic!(),
            }
        } else {
            super::JKLIHAMFKDP::JKLIHAMFKDP::new()
        }
    }

    // .FFEJOBNEKGG HOBFNKJLNHA = 13;

    pub fn HOBFNKJLNHA(&self) -> &super::FFEJOBNEKGG::FFEJOBNEKGG {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(ref v)) => v,
            _ => <super::FFEJOBNEKGG::FFEJOBNEKGG as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_HOBFNKJLNHA(&mut self) {
        self.CPNPDEJFCDN = ::std::option::Option::None;
    }

    pub fn has_HOBFNKJLNHA(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HOBFNKJLNHA(&mut self, v: super::FFEJOBNEKGG::FFEJOBNEKGG) {
        self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(v))
    }

    // Mutable pointer to the field.
    pub fn mut_HOBFNKJLNHA(&mut self) -> &mut super::FFEJOBNEKGG::FFEJOBNEKGG {
        if let ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(_)) = self.CPNPDEJFCDN {
        } else {
            self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(super::FFEJOBNEKGG::FFEJOBNEKGG::new()));
        }
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_HOBFNKJLNHA(&mut self) -> super::FFEJOBNEKGG::FFEJOBNEKGG {
        if self.has_HOBFNKJLNHA() {
            match self.CPNPDEJFCDN.take() {
                ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FFEJOBNEKGG::FFEJOBNEKGG::new()
        }
    }

    // .OAHHGHHJLKM OKGLGLFOOHE = 2;

    pub fn OKGLGLFOOHE(&self) -> &super::OAHHGHHJLKM::OAHHGHHJLKM {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(ref v)) => v,
            _ => <super::OAHHGHHJLKM::OAHHGHHJLKM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_OKGLGLFOOHE(&mut self) {
        self.CPNPDEJFCDN = ::std::option::Option::None;
    }

    pub fn has_OKGLGLFOOHE(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_OKGLGLFOOHE(&mut self, v: super::OAHHGHHJLKM::OAHHGHHJLKM) {
        self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_OKGLGLFOOHE(&mut self) -> &mut super::OAHHGHHJLKM::OAHHGHHJLKM {
        if let ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(_)) = self.CPNPDEJFCDN {
        } else {
            self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(super::OAHHGHHJLKM::OAHHGHHJLKM::new()));
        }
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_OKGLGLFOOHE(&mut self) -> super::OAHHGHHJLKM::OAHHGHHJLKM {
        if self.has_OKGLGLFOOHE() {
            match self.CPNPDEJFCDN.take() {
                ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(v)) => v,
                _ => panic!(),
            }
        } else {
            super::OAHHGHHJLKM::OAHHGHHJLKM::new()
        }
    }

    // bool FKLALBMILCA = 7;

    pub fn FKLALBMILCA(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FKLALBMILCA(v)) => v,
            _ => false,
        }
    }

    pub fn clear_FKLALBMILCA(&mut self) {
        self.CPNPDEJFCDN = ::std::option::Option::None;
    }

    pub fn has_FKLALBMILCA(&self) -> bool {
        match self.CPNPDEJFCDN {
            ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FKLALBMILCA(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FKLALBMILCA(&mut self, v: bool) {
        self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FKLALBMILCA(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "FCHMCFNFJJO",
            |m: &HDJNNHONFEB| { &m.FCHMCFNFJJO },
            |m: &mut HDJNNHONFEB| { &mut m.FCHMCFNFJJO },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::EMKEHPGJBGN::EMKEHPGJBGN>(
            "BCJJKDGBFFN",
            HDJNNHONFEB::has_BCJJKDGBFFN,
            HDJNNHONFEB::BCJJKDGBFFN,
            HDJNNHONFEB::mut_BCJJKDGBFFN,
            HDJNNHONFEB::set_BCJJKDGBFFN,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HEDFBLJLMNK::HEDFBLJLMNK>(
            "FLFGFGKNMHF",
            HDJNNHONFEB::has_FLFGFGKNMHF,
            HDJNNHONFEB::FLFGFGKNMHF,
            HDJNNHONFEB::mut_FLFGFGKNMHF,
            HDJNNHONFEB::set_FLFGFGKNMHF,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::MDCDEFONBLB::MDCDEFONBLB>(
            "CADHAOEMMIC",
            HDJNNHONFEB::has_CADHAOEMMIC,
            HDJNNHONFEB::CADHAOEMMIC,
            HDJNNHONFEB::mut_CADHAOEMMIC,
            HDJNNHONFEB::set_CADHAOEMMIC,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::GKKPEJMKPJB::GKKPEJMKPJB>(
            "EIICOHEMHCA",
            HDJNNHONFEB::has_EIICOHEMHCA,
            HDJNNHONFEB::EIICOHEMHCA,
            HDJNNHONFEB::mut_EIICOHEMHCA,
            HDJNNHONFEB::set_EIICOHEMHCA,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::JKLIHAMFKDP::JKLIHAMFKDP>(
            "INJCENAIEHM",
            HDJNNHONFEB::has_INJCENAIEHM,
            HDJNNHONFEB::INJCENAIEHM,
            HDJNNHONFEB::mut_INJCENAIEHM,
            HDJNNHONFEB::set_INJCENAIEHM,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FFEJOBNEKGG::FFEJOBNEKGG>(
            "HOBFNKJLNHA",
            HDJNNHONFEB::has_HOBFNKJLNHA,
            HDJNNHONFEB::HOBFNKJLNHA,
            HDJNNHONFEB::mut_HOBFNKJLNHA,
            HDJNNHONFEB::set_HOBFNKJLNHA,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::OAHHGHHJLKM::OAHHGHHJLKM>(
            "OKGLGLFOOHE",
            HDJNNHONFEB::has_OKGLGLFOOHE,
            HDJNNHONFEB::OKGLGLFOOHE,
            HDJNNHONFEB::mut_OKGLGLFOOHE,
            HDJNNHONFEB::set_OKGLGLFOOHE,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "FKLALBMILCA",
            HDJNNHONFEB::has_FKLALBMILCA,
            HDJNNHONFEB::FKLALBMILCA,
            HDJNNHONFEB::set_FKLALBMILCA,
        ));
        oneofs.push(hdjnnhonfeb::CPNPDEJFCDN::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HDJNNHONFEB>(
            "HDJNNHONFEB",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HDJNNHONFEB {
    const NAME: &'static str = "HDJNNHONFEB";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.FCHMCFNFJJO = is.read_uint32()?;
                },
                90 => {
                    self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(is.read_message()?));
                },
                42 => {
                    self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(is.read_message()?));
                },
                98 => {
                    self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(is.read_message()?));
                },
                10 => {
                    self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(is.read_message()?));
                },
                66 => {
                    self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(is.read_message()?));
                },
                106 => {
                    self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(is.read_message()?));
                },
                18 => {
                    self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(is.read_message()?));
                },
                56 => {
                    self.CPNPDEJFCDN = ::std::option::Option::Some(hdjnnhonfeb::CPNPDEJFCDN::FKLALBMILCA(is.read_bool()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.FCHMCFNFJJO != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.FCHMCFNFJJO);
        }
        if let ::std::option::Option::Some(ref v) = self.CPNPDEJFCDN {
            match v {
                &hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::FKLALBMILCA(v) => {
                    my_size += 1 + 1;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.FCHMCFNFJJO != 0 {
            os.write_uint32(6, self.FCHMCFNFJJO)?;
        }
        if let ::std::option::Option::Some(ref v) = self.CPNPDEJFCDN {
            match v {
                &hdjnnhonfeb::CPNPDEJFCDN::BCJJKDGBFFN(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::FLFGFGKNMHF(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::CADHAOEMMIC(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::EIICOHEMHCA(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::INJCENAIEHM(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::HOBFNKJLNHA(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::OKGLGLFOOHE(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &hdjnnhonfeb::CPNPDEJFCDN::FKLALBMILCA(v) => {
                    os.write_bool(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HDJNNHONFEB {
        HDJNNHONFEB::new()
    }

    fn clear(&mut self) {
        self.FCHMCFNFJJO = 0;
        self.CPNPDEJFCDN = ::std::option::Option::None;
        self.CPNPDEJFCDN = ::std::option::Option::None;
        self.CPNPDEJFCDN = ::std::option::Option::None;
        self.CPNPDEJFCDN = ::std::option::Option::None;
        self.CPNPDEJFCDN = ::std::option::Option::None;
        self.CPNPDEJFCDN = ::std::option::Option::None;
        self.CPNPDEJFCDN = ::std::option::Option::None;
        self.CPNPDEJFCDN = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HDJNNHONFEB {
        static instance: HDJNNHONFEB = HDJNNHONFEB {
            FCHMCFNFJJO: 0,
            CPNPDEJFCDN: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HDJNNHONFEB {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HDJNNHONFEB").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HDJNNHONFEB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HDJNNHONFEB {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HDJNNHONFEB`
pub mod hdjnnhonfeb {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:HDJNNHONFEB.CPNPDEJFCDN)
    pub enum CPNPDEJFCDN {
        // @@protoc_insertion_point(oneof_field:HDJNNHONFEB.BCJJKDGBFFN)
        BCJJKDGBFFN(super::super::EMKEHPGJBGN::EMKEHPGJBGN),
        // @@protoc_insertion_point(oneof_field:HDJNNHONFEB.FLFGFGKNMHF)
        FLFGFGKNMHF(super::super::HEDFBLJLMNK::HEDFBLJLMNK),
        // @@protoc_insertion_point(oneof_field:HDJNNHONFEB.CADHAOEMMIC)
        CADHAOEMMIC(super::super::MDCDEFONBLB::MDCDEFONBLB),
        // @@protoc_insertion_point(oneof_field:HDJNNHONFEB.EIICOHEMHCA)
        EIICOHEMHCA(super::super::GKKPEJMKPJB::GKKPEJMKPJB),
        // @@protoc_insertion_point(oneof_field:HDJNNHONFEB.INJCENAIEHM)
        INJCENAIEHM(super::super::JKLIHAMFKDP::JKLIHAMFKDP),
        // @@protoc_insertion_point(oneof_field:HDJNNHONFEB.HOBFNKJLNHA)
        HOBFNKJLNHA(super::super::FFEJOBNEKGG::FFEJOBNEKGG),
        // @@protoc_insertion_point(oneof_field:HDJNNHONFEB.OKGLGLFOOHE)
        OKGLGLFOOHE(super::super::OAHHGHHJLKM::OAHHGHHJLKM),
        // @@protoc_insertion_point(oneof_field:HDJNNHONFEB.FKLALBMILCA)
        FKLALBMILCA(bool),
    }

    impl ::protobuf::Oneof for CPNPDEJFCDN {
    }

    impl ::protobuf::OneofFull for CPNPDEJFCDN {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::HDJNNHONFEB as ::protobuf::MessageFull>::descriptor().oneof_by_name("CPNPDEJFCDN").unwrap()).clone()
        }
    }

    impl CPNPDEJFCDN {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<CPNPDEJFCDN>("CPNPDEJFCDN")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11HDJNNHONFEB.proto\x1a\x11EMKEHPGJBGN.proto\x1a\x11FFEJOBNEKGG.prot\
    o\x1a\x11GKKPEJMKPJB.proto\x1a\x11HEDFBLJLMNK.proto\x1a\x11JKLIHAMFKDP.p\
    roto\x1a\x11MDCDEFONBLB.proto\x1a\x11OAHHGHHJLKM.proto\"\xc0\x03\n\x0bHD\
    JNNHONFEB\x12\x20\n\x0bFCHMCFNFJJO\x18\x06\x20\x01(\rR\x0bFCHMCFNFJJO\
    \x120\n\x0bBCJJKDGBFFN\x18\x0b\x20\x01(\x0b2\x0c.EMKEHPGJBGNH\0R\x0bBCJJ\
    KDGBFFN\x120\n\x0bFLFGFGKNMHF\x18\x05\x20\x01(\x0b2\x0c.HEDFBLJLMNKH\0R\
    \x0bFLFGFGKNMHF\x120\n\x0bCADHAOEMMIC\x18\x0c\x20\x01(\x0b2\x0c.MDCDEFON\
    BLBH\0R\x0bCADHAOEMMIC\x120\n\x0bEIICOHEMHCA\x18\x01\x20\x01(\x0b2\x0c.G\
    KKPEJMKPJBH\0R\x0bEIICOHEMHCA\x120\n\x0bINJCENAIEHM\x18\x08\x20\x01(\x0b\
    2\x0c.JKLIHAMFKDPH\0R\x0bINJCENAIEHM\x120\n\x0bHOBFNKJLNHA\x18\r\x20\x01\
    (\x0b2\x0c.FFEJOBNEKGGH\0R\x0bHOBFNKJLNHA\x120\n\x0bOKGLGLFOOHE\x18\x02\
    \x20\x01(\x0b2\x0c.OAHHGHHJLKMH\0R\x0bOKGLGLFOOHE\x12\"\n\x0bFKLALBMILCA\
    \x18\x07\x20\x01(\x08H\0R\x0bFKLALBMILCAB\r\n\x0bCPNPDEJFCDNb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(7);
            deps.push(super::EMKEHPGJBGN::file_descriptor().clone());
            deps.push(super::FFEJOBNEKGG::file_descriptor().clone());
            deps.push(super::GKKPEJMKPJB::file_descriptor().clone());
            deps.push(super::HEDFBLJLMNK::file_descriptor().clone());
            deps.push(super::JKLIHAMFKDP::file_descriptor().clone());
            deps.push(super::MDCDEFONBLB::file_descriptor().clone());
            deps.push(super::OAHHGHHJLKM::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(HDJNNHONFEB::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
