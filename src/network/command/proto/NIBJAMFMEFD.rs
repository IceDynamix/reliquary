// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `NIBJAMFMEFD.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:NIBJAMFMEFD)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NIBJAMFMEFD {
    // message oneof groups
    pub FBKHKLGJMFH: ::std::option::Option<nibjamfmefd::FBKHKLGJMFH>,
    // special fields
    // @@protoc_insertion_point(special_field:NIBJAMFMEFD.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NIBJAMFMEFD {
    fn default() -> &'a NIBJAMFMEFD {
        <NIBJAMFMEFD as ::protobuf::Message>::default_instance()
    }
}

impl NIBJAMFMEFD {
    pub fn new() -> NIBJAMFMEFD {
        ::std::default::Default::default()
    }

    // .LMKAAEFPFFO MECLLCDABNO = 3;

    pub fn MECLLCDABNO(&self) -> &super::LMKAAEFPFFO::LMKAAEFPFFO {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(ref v)) => v,
            _ => <super::LMKAAEFPFFO::LMKAAEFPFFO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_MECLLCDABNO(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_MECLLCDABNO(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_MECLLCDABNO(&mut self, v: super::LMKAAEFPFFO::LMKAAEFPFFO) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(v))
    }

    // Mutable pointer to the field.
    pub fn mut_MECLLCDABNO(&mut self) -> &mut super::LMKAAEFPFFO::LMKAAEFPFFO {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(super::LMKAAEFPFFO::LMKAAEFPFFO::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_MECLLCDABNO(&mut self) -> super::LMKAAEFPFFO::LMKAAEFPFFO {
        if self.has_MECLLCDABNO() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LMKAAEFPFFO::LMKAAEFPFFO::new()
        }
    }

    // .LMKAAEFPFFO FFIPKMHCKHJ = 9;

    pub fn FFIPKMHCKHJ(&self) -> &super::LMKAAEFPFFO::LMKAAEFPFFO {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(ref v)) => v,
            _ => <super::LMKAAEFPFFO::LMKAAEFPFFO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_FFIPKMHCKHJ(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_FFIPKMHCKHJ(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FFIPKMHCKHJ(&mut self, v: super::LMKAAEFPFFO::LMKAAEFPFFO) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(v))
    }

    // Mutable pointer to the field.
    pub fn mut_FFIPKMHCKHJ(&mut self) -> &mut super::LMKAAEFPFFO::LMKAAEFPFFO {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(super::LMKAAEFPFFO::LMKAAEFPFFO::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_FFIPKMHCKHJ(&mut self) -> super::LMKAAEFPFFO::LMKAAEFPFFO {
        if self.has_FFIPKMHCKHJ() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LMKAAEFPFFO::LMKAAEFPFFO::new()
        }
    }

    // .AIDFBBIAPEP MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE = 2;

    pub fn MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&self) -> &super::AIDFBBIAPEP::AIDFBBIAPEP {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(ref v)) => v,
            _ => <super::AIDFBBIAPEP::AIDFBBIAPEP as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&mut self, v: super::AIDFBBIAPEP::AIDFBBIAPEP) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&mut self) -> &mut super::AIDFBBIAPEP::AIDFBBIAPEP {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(super::AIDFBBIAPEP::AIDFBBIAPEP::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE(&mut self) -> super::AIDFBBIAPEP::AIDFBBIAPEP {
        if self.has_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(v)) => v,
                _ => panic!(),
            }
        } else {
            super::AIDFBBIAPEP::AIDFBBIAPEP::new()
        }
    }

    // .AIDFBBIAPEP DACHANHPPBG = 10;

    pub fn DACHANHPPBG(&self) -> &super::AIDFBBIAPEP::AIDFBBIAPEP {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(ref v)) => v,
            _ => <super::AIDFBBIAPEP::AIDFBBIAPEP as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_DACHANHPPBG(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_DACHANHPPBG(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DACHANHPPBG(&mut self, v: super::AIDFBBIAPEP::AIDFBBIAPEP) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DACHANHPPBG(&mut self) -> &mut super::AIDFBBIAPEP::AIDFBBIAPEP {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(super::AIDFBBIAPEP::AIDFBBIAPEP::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DACHANHPPBG(&mut self) -> super::AIDFBBIAPEP::AIDFBBIAPEP {
        if self.has_DACHANHPPBG() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(v)) => v,
                _ => panic!(),
            }
        } else {
            super::AIDFBBIAPEP::AIDFBBIAPEP::new()
        }
    }

    // .BMPLFJKEOLF NOENHHILNAH = 1;

    pub fn NOENHHILNAH(&self) -> &super::BMPLFJKEOLF::BMPLFJKEOLF {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(ref v)) => v,
            _ => <super::BMPLFJKEOLF::BMPLFJKEOLF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NOENHHILNAH(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_NOENHHILNAH(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NOENHHILNAH(&mut self, v: super::BMPLFJKEOLF::BMPLFJKEOLF) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NOENHHILNAH(&mut self) -> &mut super::BMPLFJKEOLF::BMPLFJKEOLF {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(super::BMPLFJKEOLF::BMPLFJKEOLF::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NOENHHILNAH(&mut self) -> super::BMPLFJKEOLF::BMPLFJKEOLF {
        if self.has_NOENHHILNAH() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BMPLFJKEOLF::BMPLFJKEOLF::new()
        }
    }

    // .BMPLFJKEOLF KPBJIPGEJPL = 4;

    pub fn KPBJIPGEJPL(&self) -> &super::BMPLFJKEOLF::BMPLFJKEOLF {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(ref v)) => v,
            _ => <super::BMPLFJKEOLF::BMPLFJKEOLF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_KPBJIPGEJPL(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_KPBJIPGEJPL(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_KPBJIPGEJPL(&mut self, v: super::BMPLFJKEOLF::BMPLFJKEOLF) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(v))
    }

    // Mutable pointer to the field.
    pub fn mut_KPBJIPGEJPL(&mut self) -> &mut super::BMPLFJKEOLF::BMPLFJKEOLF {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(super::BMPLFJKEOLF::BMPLFJKEOLF::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_KPBJIPGEJPL(&mut self) -> super::BMPLFJKEOLF::BMPLFJKEOLF {
        if self.has_KPBJIPGEJPL() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BMPLFJKEOLF::BMPLFJKEOLF::new()
        }
    }

    // .LNKMKNBPIJH DMDPCOOAFJK = 11;

    pub fn DMDPCOOAFJK(&self) -> &super::LNKMKNBPIJH::LNKMKNBPIJH {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(ref v)) => v,
            _ => <super::LNKMKNBPIJH::LNKMKNBPIJH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_DMDPCOOAFJK(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_DMDPCOOAFJK(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DMDPCOOAFJK(&mut self, v: super::LNKMKNBPIJH::LNKMKNBPIJH) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DMDPCOOAFJK(&mut self) -> &mut super::LNKMKNBPIJH::LNKMKNBPIJH {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(super::LNKMKNBPIJH::LNKMKNBPIJH::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DMDPCOOAFJK(&mut self) -> super::LNKMKNBPIJH::LNKMKNBPIJH {
        if self.has_DMDPCOOAFJK() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LNKMKNBPIJH::LNKMKNBPIJH::new()
        }
    }

    // .LNKMKNBPIJH HHIBFNAGKFF = 6;

    pub fn HHIBFNAGKFF(&self) -> &super::LNKMKNBPIJH::LNKMKNBPIJH {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(ref v)) => v,
            _ => <super::LNKMKNBPIJH::LNKMKNBPIJH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_HHIBFNAGKFF(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_HHIBFNAGKFF(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HHIBFNAGKFF(&mut self, v: super::LNKMKNBPIJH::LNKMKNBPIJH) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(v))
    }

    // Mutable pointer to the field.
    pub fn mut_HHIBFNAGKFF(&mut self) -> &mut super::LNKMKNBPIJH::LNKMKNBPIJH {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(super::LNKMKNBPIJH::LNKMKNBPIJH::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_HHIBFNAGKFF(&mut self) -> super::LNKMKNBPIJH::LNKMKNBPIJH {
        if self.has_HHIBFNAGKFF() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LNKMKNBPIJH::LNKMKNBPIJH::new()
        }
    }

    // .LMMEBMBGLDN NKCMGBCPJGG = 13;

    pub fn NKCMGBCPJGG(&self) -> &super::LMMEBMBGLDN::LMMEBMBGLDN {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(ref v)) => v,
            _ => <super::LMMEBMBGLDN::LMMEBMBGLDN as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NKCMGBCPJGG(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_NKCMGBCPJGG(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NKCMGBCPJGG(&mut self, v: super::LMMEBMBGLDN::LMMEBMBGLDN) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NKCMGBCPJGG(&mut self) -> &mut super::LMMEBMBGLDN::LMMEBMBGLDN {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(super::LMMEBMBGLDN::LMMEBMBGLDN::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NKCMGBCPJGG(&mut self) -> super::LMMEBMBGLDN::LMMEBMBGLDN {
        if self.has_NKCMGBCPJGG() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LMMEBMBGLDN::LMMEBMBGLDN::new()
        }
    }

    // .LPBAMOKKJCM HANOGACJPKB = 8;

    pub fn HANOGACJPKB(&self) -> &super::LPBAMOKKJCM::LPBAMOKKJCM {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(ref v)) => v,
            _ => <super::LPBAMOKKJCM::LPBAMOKKJCM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_HANOGACJPKB(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_HANOGACJPKB(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HANOGACJPKB(&mut self, v: super::LPBAMOKKJCM::LPBAMOKKJCM) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(v))
    }

    // Mutable pointer to the field.
    pub fn mut_HANOGACJPKB(&mut self) -> &mut super::LPBAMOKKJCM::LPBAMOKKJCM {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(super::LPBAMOKKJCM::LPBAMOKKJCM::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_HANOGACJPKB(&mut self) -> super::LPBAMOKKJCM::LPBAMOKKJCM {
        if self.has_HANOGACJPKB() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LPBAMOKKJCM::LPBAMOKKJCM::new()
        }
    }

    // .BMPLFJKEOLF OMFECIMLADC = 7;

    pub fn OMFECIMLADC(&self) -> &super::BMPLFJKEOLF::BMPLFJKEOLF {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(ref v)) => v,
            _ => <super::BMPLFJKEOLF::BMPLFJKEOLF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_OMFECIMLADC(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_OMFECIMLADC(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_OMFECIMLADC(&mut self, v: super::BMPLFJKEOLF::BMPLFJKEOLF) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(v))
    }

    // Mutable pointer to the field.
    pub fn mut_OMFECIMLADC(&mut self) -> &mut super::BMPLFJKEOLF::BMPLFJKEOLF {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(super::BMPLFJKEOLF::BMPLFJKEOLF::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_OMFECIMLADC(&mut self) -> super::BMPLFJKEOLF::BMPLFJKEOLF {
        if self.has_OMFECIMLADC() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(v)) => v,
                _ => panic!(),
            }
        } else {
            super::BMPLFJKEOLF::BMPLFJKEOLF::new()
        }
    }

    // .LNKMKNBPIJH NGONCCBLAOL = 5;

    pub fn NGONCCBLAOL(&self) -> &super::LNKMKNBPIJH::LNKMKNBPIJH {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(ref v)) => v,
            _ => <super::LNKMKNBPIJH::LNKMKNBPIJH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_NGONCCBLAOL(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_NGONCCBLAOL(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_NGONCCBLAOL(&mut self, v: super::LNKMKNBPIJH::LNKMKNBPIJH) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(v))
    }

    // Mutable pointer to the field.
    pub fn mut_NGONCCBLAOL(&mut self) -> &mut super::LNKMKNBPIJH::LNKMKNBPIJH {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(super::LNKMKNBPIJH::LNKMKNBPIJH::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_NGONCCBLAOL(&mut self) -> super::LNKMKNBPIJH::LNKMKNBPIJH {
        if self.has_NGONCCBLAOL() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LNKMKNBPIJH::LNKMKNBPIJH::new()
        }
    }

    // .NMGHFOLKFAJ FJGHNLNJLPH = 14;

    pub fn FJGHNLNJLPH(&self) -> &super::NMGHFOLKFAJ::NMGHFOLKFAJ {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(ref v)) => v,
            _ => <super::NMGHFOLKFAJ::NMGHFOLKFAJ as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_FJGHNLNJLPH(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
    }

    pub fn has_FJGHNLNJLPH(&self) -> bool {
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FJGHNLNJLPH(&mut self, v: super::NMGHFOLKFAJ::NMGHFOLKFAJ) {
        self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_FJGHNLNJLPH(&mut self) -> &mut super::NMGHFOLKFAJ::NMGHFOLKFAJ {
        if let ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(_)) = self.FBKHKLGJMFH {
        } else {
            self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(super::NMGHFOLKFAJ::NMGHFOLKFAJ::new()));
        }
        match self.FBKHKLGJMFH {
            ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_FJGHNLNJLPH(&mut self) -> super::NMGHFOLKFAJ::NMGHFOLKFAJ {
        if self.has_FJGHNLNJLPH() {
            match self.FBKHKLGJMFH.take() {
                ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NMGHFOLKFAJ::NMGHFOLKFAJ::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LMKAAEFPFFO::LMKAAEFPFFO>(
            "MECLLCDABNO",
            NIBJAMFMEFD::has_MECLLCDABNO,
            NIBJAMFMEFD::MECLLCDABNO,
            NIBJAMFMEFD::mut_MECLLCDABNO,
            NIBJAMFMEFD::set_MECLLCDABNO,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LMKAAEFPFFO::LMKAAEFPFFO>(
            "FFIPKMHCKHJ",
            NIBJAMFMEFD::has_FFIPKMHCKHJ,
            NIBJAMFMEFD::FFIPKMHCKHJ,
            NIBJAMFMEFD::mut_FFIPKMHCKHJ,
            NIBJAMFMEFD::set_FFIPKMHCKHJ,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::AIDFBBIAPEP::AIDFBBIAPEP>(
            "MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE",
            NIBJAMFMEFD::has_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE,
            NIBJAMFMEFD::MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE,
            NIBJAMFMEFD::mut_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE,
            NIBJAMFMEFD::set_MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::AIDFBBIAPEP::AIDFBBIAPEP>(
            "DACHANHPPBG",
            NIBJAMFMEFD::has_DACHANHPPBG,
            NIBJAMFMEFD::DACHANHPPBG,
            NIBJAMFMEFD::mut_DACHANHPPBG,
            NIBJAMFMEFD::set_DACHANHPPBG,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BMPLFJKEOLF::BMPLFJKEOLF>(
            "NOENHHILNAH",
            NIBJAMFMEFD::has_NOENHHILNAH,
            NIBJAMFMEFD::NOENHHILNAH,
            NIBJAMFMEFD::mut_NOENHHILNAH,
            NIBJAMFMEFD::set_NOENHHILNAH,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BMPLFJKEOLF::BMPLFJKEOLF>(
            "KPBJIPGEJPL",
            NIBJAMFMEFD::has_KPBJIPGEJPL,
            NIBJAMFMEFD::KPBJIPGEJPL,
            NIBJAMFMEFD::mut_KPBJIPGEJPL,
            NIBJAMFMEFD::set_KPBJIPGEJPL,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LNKMKNBPIJH::LNKMKNBPIJH>(
            "DMDPCOOAFJK",
            NIBJAMFMEFD::has_DMDPCOOAFJK,
            NIBJAMFMEFD::DMDPCOOAFJK,
            NIBJAMFMEFD::mut_DMDPCOOAFJK,
            NIBJAMFMEFD::set_DMDPCOOAFJK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LNKMKNBPIJH::LNKMKNBPIJH>(
            "HHIBFNAGKFF",
            NIBJAMFMEFD::has_HHIBFNAGKFF,
            NIBJAMFMEFD::HHIBFNAGKFF,
            NIBJAMFMEFD::mut_HHIBFNAGKFF,
            NIBJAMFMEFD::set_HHIBFNAGKFF,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LMMEBMBGLDN::LMMEBMBGLDN>(
            "NKCMGBCPJGG",
            NIBJAMFMEFD::has_NKCMGBCPJGG,
            NIBJAMFMEFD::NKCMGBCPJGG,
            NIBJAMFMEFD::mut_NKCMGBCPJGG,
            NIBJAMFMEFD::set_NKCMGBCPJGG,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LPBAMOKKJCM::LPBAMOKKJCM>(
            "HANOGACJPKB",
            NIBJAMFMEFD::has_HANOGACJPKB,
            NIBJAMFMEFD::HANOGACJPKB,
            NIBJAMFMEFD::mut_HANOGACJPKB,
            NIBJAMFMEFD::set_HANOGACJPKB,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::BMPLFJKEOLF::BMPLFJKEOLF>(
            "OMFECIMLADC",
            NIBJAMFMEFD::has_OMFECIMLADC,
            NIBJAMFMEFD::OMFECIMLADC,
            NIBJAMFMEFD::mut_OMFECIMLADC,
            NIBJAMFMEFD::set_OMFECIMLADC,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LNKMKNBPIJH::LNKMKNBPIJH>(
            "NGONCCBLAOL",
            NIBJAMFMEFD::has_NGONCCBLAOL,
            NIBJAMFMEFD::NGONCCBLAOL,
            NIBJAMFMEFD::mut_NGONCCBLAOL,
            NIBJAMFMEFD::set_NGONCCBLAOL,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NMGHFOLKFAJ::NMGHFOLKFAJ>(
            "FJGHNLNJLPH",
            NIBJAMFMEFD::has_FJGHNLNJLPH,
            NIBJAMFMEFD::FJGHNLNJLPH,
            NIBJAMFMEFD::mut_FJGHNLNJLPH,
            NIBJAMFMEFD::set_FJGHNLNJLPH,
        ));
        oneofs.push(nibjamfmefd::FBKHKLGJMFH::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NIBJAMFMEFD>(
            "NIBJAMFMEFD",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NIBJAMFMEFD {
    const NAME: &'static str = "NIBJAMFMEFD";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(is.read_message()?));
                },
                74 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(is.read_message()?));
                },
                18 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(is.read_message()?));
                },
                82 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(is.read_message()?));
                },
                10 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(is.read_message()?));
                },
                34 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(is.read_message()?));
                },
                90 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(is.read_message()?));
                },
                50 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(is.read_message()?));
                },
                106 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(is.read_message()?));
                },
                66 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(is.read_message()?));
                },
                58 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(is.read_message()?));
                },
                42 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(is.read_message()?));
                },
                114 => {
                    self.FBKHKLGJMFH = ::std::option::Option::Some(nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.FBKHKLGJMFH {
            match v {
                &nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.FBKHKLGJMFH {
            match v {
                &nibjamfmefd::FBKHKLGJMFH::MECLLCDABNO(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::FFIPKMHCKHJ(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::DACHANHPPBG(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::NOENHHILNAH(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::KPBJIPGEJPL(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::DMDPCOOAFJK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::HHIBFNAGKFF(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::NKCMGBCPJGG(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::HANOGACJPKB(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::OMFECIMLADC(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::NGONCCBLAOL(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &nibjamfmefd::FBKHKLGJMFH::FJGHNLNJLPH(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NIBJAMFMEFD {
        NIBJAMFMEFD::new()
    }

    fn clear(&mut self) {
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.FBKHKLGJMFH = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NIBJAMFMEFD {
        static instance: NIBJAMFMEFD = NIBJAMFMEFD {
            FBKHKLGJMFH: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NIBJAMFMEFD {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NIBJAMFMEFD").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NIBJAMFMEFD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NIBJAMFMEFD {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NIBJAMFMEFD`
pub mod nibjamfmefd {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:NIBJAMFMEFD.FBKHKLGJMFH)
    pub enum FBKHKLGJMFH {
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.MECLLCDABNO)
        MECLLCDABNO(super::super::LMKAAEFPFFO::LMKAAEFPFFO),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.FFIPKMHCKHJ)
        FFIPKMHCKHJ(super::super::LMKAAEFPFFO::LMKAAEFPFFO),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UPGRADE)
        MONOPOLYACTIONRESULTSOURCETYPEASSETUPGRADE(super::super::AIDFBBIAPEP::AIDFBBIAPEP),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.DACHANHPPBG)
        DACHANHPPBG(super::super::AIDFBBIAPEP::AIDFBBIAPEP),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.NOENHHILNAH)
        NOENHHILNAH(super::super::BMPLFJKEOLF::BMPLFJKEOLF),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.KPBJIPGEJPL)
        KPBJIPGEJPL(super::super::BMPLFJKEOLF::BMPLFJKEOLF),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.DMDPCOOAFJK)
        DMDPCOOAFJK(super::super::LNKMKNBPIJH::LNKMKNBPIJH),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.HHIBFNAGKFF)
        HHIBFNAGKFF(super::super::LNKMKNBPIJH::LNKMKNBPIJH),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.NKCMGBCPJGG)
        NKCMGBCPJGG(super::super::LMMEBMBGLDN::LMMEBMBGLDN),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.HANOGACJPKB)
        HANOGACJPKB(super::super::LPBAMOKKJCM::LPBAMOKKJCM),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.OMFECIMLADC)
        OMFECIMLADC(super::super::BMPLFJKEOLF::BMPLFJKEOLF),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.NGONCCBLAOL)
        NGONCCBLAOL(super::super::LNKMKNBPIJH::LNKMKNBPIJH),
        // @@protoc_insertion_point(oneof_field:NIBJAMFMEFD.FJGHNLNJLPH)
        FJGHNLNJLPH(super::super::NMGHFOLKFAJ::NMGHFOLKFAJ),
    }

    impl ::protobuf::Oneof for FBKHKLGJMFH {
    }

    impl ::protobuf::OneofFull for FBKHKLGJMFH {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::NIBJAMFMEFD as ::protobuf::MessageFull>::descriptor().oneof_by_name("FBKHKLGJMFH").unwrap()).clone()
        }
    }

    impl FBKHKLGJMFH {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<FBKHKLGJMFH>("FBKHKLGJMFH")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11NIBJAMFMEFD.proto\x1a\x11AIDFBBIAPEP.proto\x1a\x11BMPLFJKEOLF.prot\
    o\x1a\x11LMKAAEFPFFO.proto\x1a\x11LMMEBMBGLDN.proto\x1a\x11LNKMKNBPIJH.p\
    roto\x1a\x11LPBAMOKKJCM.proto\x1a\x11NMGHFOLKFAJ.proto\"\xea\x05\n\x0bNI\
    BJAMFMEFD\x120\n\x0bMECLLCDABNO\x18\x03\x20\x01(\x0b2\x0c.LMKAAEFPFFOH\0\
    R\x0bMECLLCDABNO\x120\n\x0bFFIPKMHCKHJ\x18\t\x20\x01(\x0b2\x0c.LMKAAEFPF\
    FOH\0R\x0bFFIPKMHCKHJ\x12t\n0MONOPOLY_ACTION_RESULT_SOURCE_TYPE_ASSET_UP\
    GRADE\x18\x02\x20\x01(\x0b2\x0c.AIDFBBIAPEPH\0R*MONOPOLYACTIONRESULTSOUR\
    CETYPEASSETUPGRADE\x120\n\x0bDACHANHPPBG\x18\n\x20\x01(\x0b2\x0c.AIDFBBI\
    APEPH\0R\x0bDACHANHPPBG\x120\n\x0bNOENHHILNAH\x18\x01\x20\x01(\x0b2\x0c.\
    BMPLFJKEOLFH\0R\x0bNOENHHILNAH\x120\n\x0bKPBJIPGEJPL\x18\x04\x20\x01(\
    \x0b2\x0c.BMPLFJKEOLFH\0R\x0bKPBJIPGEJPL\x120\n\x0bDMDPCOOAFJK\x18\x0b\
    \x20\x01(\x0b2\x0c.LNKMKNBPIJHH\0R\x0bDMDPCOOAFJK\x120\n\x0bHHIBFNAGKFF\
    \x18\x06\x20\x01(\x0b2\x0c.LNKMKNBPIJHH\0R\x0bHHIBFNAGKFF\x120\n\x0bNKCM\
    GBCPJGG\x18\r\x20\x01(\x0b2\x0c.LMMEBMBGLDNH\0R\x0bNKCMGBCPJGG\x120\n\
    \x0bHANOGACJPKB\x18\x08\x20\x01(\x0b2\x0c.LPBAMOKKJCMH\0R\x0bHANOGACJPKB\
    \x120\n\x0bOMFECIMLADC\x18\x07\x20\x01(\x0b2\x0c.BMPLFJKEOLFH\0R\x0bOMFE\
    CIMLADC\x120\n\x0bNGONCCBLAOL\x18\x05\x20\x01(\x0b2\x0c.LNKMKNBPIJHH\0R\
    \x0bNGONCCBLAOL\x120\n\x0bFJGHNLNJLPH\x18\x0e\x20\x01(\x0b2\x0c.NMGHFOLK\
    FAJH\0R\x0bFJGHNLNJLPHB\r\n\x0bFBKHKLGJMFHb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(7);
            deps.push(super::AIDFBBIAPEP::file_descriptor().clone());
            deps.push(super::BMPLFJKEOLF::file_descriptor().clone());
            deps.push(super::LMKAAEFPFFO::file_descriptor().clone());
            deps.push(super::LMMEBMBGLDN::file_descriptor().clone());
            deps.push(super::LNKMKNBPIJH::file_descriptor().clone());
            deps.push(super::LPBAMOKKJCM::file_descriptor().clone());
            deps.push(super::NMGHFOLKFAJ::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(NIBJAMFMEFD::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
