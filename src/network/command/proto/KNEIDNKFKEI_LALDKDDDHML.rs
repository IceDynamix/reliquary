// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `KNEIDNKFKEI_LALDKDDDHML.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:LALDKDDDHML)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LALDKDDDHML {
    // message fields
    // @@protoc_insertion_point(field:LALDKDDDHML.DHKIPLIFBEK)
    pub DHKIPLIFBEK: ::std::vec::Vec<KNEIDNKFKEI>,
    // @@protoc_insertion_point(field:LALDKDDDHML.HGPAEBHKAHI)
    pub HGPAEBHKAHI: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LALDKDDDHML.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LALDKDDDHML {
    fn default() -> &'a LALDKDDDHML {
        <LALDKDDDHML as ::protobuf::Message>::default_instance()
    }
}

impl LALDKDDDHML {
    pub fn new() -> LALDKDDDHML {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "DHKIPLIFBEK",
            |m: &LALDKDDDHML| { &m.DHKIPLIFBEK },
            |m: &mut LALDKDDDHML| { &mut m.DHKIPLIFBEK },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HGPAEBHKAHI",
            |m: &LALDKDDDHML| { &m.HGPAEBHKAHI },
            |m: &mut LALDKDDDHML| { &mut m.HGPAEBHKAHI },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LALDKDDDHML>(
            "LALDKDDDHML",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LALDKDDDHML {
    const NAME: &'static str = "LALDKDDDHML";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.DHKIPLIFBEK.push(is.read_message()?);
                },
                16 => {
                    self.HGPAEBHKAHI = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.DHKIPLIFBEK {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.HGPAEBHKAHI != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.HGPAEBHKAHI);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.DHKIPLIFBEK {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.HGPAEBHKAHI != 0 {
            os.write_uint32(2, self.HGPAEBHKAHI)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LALDKDDDHML {
        LALDKDDDHML::new()
    }

    fn clear(&mut self) {
        self.DHKIPLIFBEK.clear();
        self.HGPAEBHKAHI = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LALDKDDDHML {
        static instance: LALDKDDDHML = LALDKDDDHML {
            DHKIPLIFBEK: ::std::vec::Vec::new(),
            HGPAEBHKAHI: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LALDKDDDHML {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LALDKDDDHML").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LALDKDDDHML {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LALDKDDDHML {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:KNEIDNKFKEI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct KNEIDNKFKEI {
    // message fields
    // @@protoc_insertion_point(field:KNEIDNKFKEI.PKGJEALMBND)
    pub PKGJEALMBND: u32,
    // message oneof groups
    pub EBCJPNHKDBP: ::std::option::Option<kneidnkfkei::EBCJPNHKDBP>,
    // special fields
    // @@protoc_insertion_point(special_field:KNEIDNKFKEI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KNEIDNKFKEI {
    fn default() -> &'a KNEIDNKFKEI {
        <KNEIDNKFKEI as ::protobuf::Message>::default_instance()
    }
}

impl KNEIDNKFKEI {
    pub fn new() -> KNEIDNKFKEI {
        ::std::default::Default::default()
    }

    // .CFEAAIAKOJD LHKCLKLGDLO = 13;

    pub fn LHKCLKLGDLO(&self) -> &super::CFEAAIAKOJD::CFEAAIAKOJD {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(ref v)) => v,
            _ => <super::CFEAAIAKOJD::CFEAAIAKOJD as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LHKCLKLGDLO(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_LHKCLKLGDLO(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LHKCLKLGDLO(&mut self, v: super::CFEAAIAKOJD::CFEAAIAKOJD) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LHKCLKLGDLO(&mut self) -> &mut super::CFEAAIAKOJD::CFEAAIAKOJD {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(super::CFEAAIAKOJD::CFEAAIAKOJD::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LHKCLKLGDLO(&mut self) -> super::CFEAAIAKOJD::CFEAAIAKOJD {
        if self.has_LHKCLKLGDLO() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CFEAAIAKOJD::CFEAAIAKOJD::new()
        }
    }

    // .IODAHNJLBFK FHLBKAKDAHL = 11;

    pub fn FHLBKAKDAHL(&self) -> &super::IODAHNJLBFK::IODAHNJLBFK {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(ref v)) => v,
            _ => <super::IODAHNJLBFK::IODAHNJLBFK as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_FHLBKAKDAHL(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_FHLBKAKDAHL(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_FHLBKAKDAHL(&mut self, v: super::IODAHNJLBFK::IODAHNJLBFK) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(v))
    }

    // Mutable pointer to the field.
    pub fn mut_FHLBKAKDAHL(&mut self) -> &mut super::IODAHNJLBFK::IODAHNJLBFK {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(super::IODAHNJLBFK::IODAHNJLBFK::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_FHLBKAKDAHL(&mut self) -> super::IODAHNJLBFK::IODAHNJLBFK {
        if self.has_FHLBKAKDAHL() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(v)) => v,
                _ => panic!(),
            }
        } else {
            super::IODAHNJLBFK::IODAHNJLBFK::new()
        }
    }

    // .FLFFNHBILPM AOCICHLHMIK = 6;

    pub fn AOCICHLHMIK(&self) -> &super::FLFFNHBILPM::FLFFNHBILPM {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(ref v)) => v,
            _ => <super::FLFFNHBILPM::FLFFNHBILPM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_AOCICHLHMIK(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_AOCICHLHMIK(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_AOCICHLHMIK(&mut self, v: super::FLFFNHBILPM::FLFFNHBILPM) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_AOCICHLHMIK(&mut self) -> &mut super::FLFFNHBILPM::FLFFNHBILPM {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(super::FLFFNHBILPM::FLFFNHBILPM::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_AOCICHLHMIK(&mut self) -> super::FLFFNHBILPM::FLFFNHBILPM {
        if self.has_AOCICHLHMIK() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FLFFNHBILPM::FLFFNHBILPM::new()
        }
    }

    // .JGNHFHAELDP JKLMFJNPHPK = 15;

    pub fn JKLMFJNPHPK(&self) -> &super::JGNHFHAELDP::JGNHFHAELDP {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(ref v)) => v,
            _ => <super::JGNHFHAELDP::JGNHFHAELDP as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_JKLMFJNPHPK(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_JKLMFJNPHPK(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_JKLMFJNPHPK(&mut self, v: super::JGNHFHAELDP::JGNHFHAELDP) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_JKLMFJNPHPK(&mut self) -> &mut super::JGNHFHAELDP::JGNHFHAELDP {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(super::JGNHFHAELDP::JGNHFHAELDP::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_JKLMFJNPHPK(&mut self) -> super::JGNHFHAELDP::JGNHFHAELDP {
        if self.has_JKLMFJNPHPK() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(v)) => v,
                _ => panic!(),
            }
        } else {
            super::JGNHFHAELDP::JGNHFHAELDP::new()
        }
    }

    // .NKHOPLIFDPI shop_sync_info = 8;

    pub fn shop_sync_info(&self) -> &super::NKHOPLIFDPI::NKHOPLIFDPI {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(ref v)) => v,
            _ => <super::NKHOPLIFDPI::NKHOPLIFDPI as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_shop_sync_info(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_shop_sync_info(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shop_sync_info(&mut self, v: super::NKHOPLIFDPI::NKHOPLIFDPI) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shop_sync_info(&mut self) -> &mut super::NKHOPLIFDPI::NKHOPLIFDPI {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(super::NKHOPLIFDPI::NKHOPLIFDPI::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shop_sync_info(&mut self) -> super::NKHOPLIFDPI::NKHOPLIFDPI {
        if self.has_shop_sync_info() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NKHOPLIFDPI::NKHOPLIFDPI::new()
        }
    }

    // .LOOHAEDJAGK HLEOICFJJOO = 10;

    pub fn HLEOICFJJOO(&self) -> &super::LOOHAEDJAGK::LOOHAEDJAGK {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(ref v)) => v,
            _ => <super::LOOHAEDJAGK::LOOHAEDJAGK as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_HLEOICFJJOO(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_HLEOICFJJOO(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_HLEOICFJJOO(&mut self, v: super::LOOHAEDJAGK::LOOHAEDJAGK) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(v))
    }

    // Mutable pointer to the field.
    pub fn mut_HLEOICFJJOO(&mut self) -> &mut super::LOOHAEDJAGK::LOOHAEDJAGK {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(super::LOOHAEDJAGK::LOOHAEDJAGK::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_HLEOICFJJOO(&mut self) -> super::LOOHAEDJAGK::LOOHAEDJAGK {
        if self.has_HLEOICFJJOO() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LOOHAEDJAGK::LOOHAEDJAGK::new()
        }
    }

    // .LKNOOLJPAGM CCFIOBOBFLO = 4;

    pub fn CCFIOBOBFLO(&self) -> &super::LKNOOLJPAGM::LKNOOLJPAGM {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(ref v)) => v,
            _ => <super::LKNOOLJPAGM::LKNOOLJPAGM as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_CCFIOBOBFLO(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_CCFIOBOBFLO(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_CCFIOBOBFLO(&mut self, v: super::LKNOOLJPAGM::LKNOOLJPAGM) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(v))
    }

    // Mutable pointer to the field.
    pub fn mut_CCFIOBOBFLO(&mut self) -> &mut super::LKNOOLJPAGM::LKNOOLJPAGM {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(super::LKNOOLJPAGM::LKNOOLJPAGM::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_CCFIOBOBFLO(&mut self) -> super::LKNOOLJPAGM::LKNOOLJPAGM {
        if self.has_CCFIOBOBFLO() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(v)) => v,
                _ => panic!(),
            }
        } else {
            super::LKNOOLJPAGM::LKNOOLJPAGM::new()
        }
    }

    // .CDBMLJOGGLO LHLMAIELHHE = 14;

    pub fn LHLMAIELHHE(&self) -> &super::CDBMLJOGGLO::CDBMLJOGGLO {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(ref v)) => v,
            _ => <super::CDBMLJOGGLO::CDBMLJOGGLO as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_LHLMAIELHHE(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_LHLMAIELHHE(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_LHLMAIELHHE(&mut self, v: super::CDBMLJOGGLO::CDBMLJOGGLO) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(v))
    }

    // Mutable pointer to the field.
    pub fn mut_LHLMAIELHHE(&mut self) -> &mut super::CDBMLJOGGLO::CDBMLJOGGLO {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(super::CDBMLJOGGLO::CDBMLJOGGLO::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_LHLMAIELHHE(&mut self) -> super::CDBMLJOGGLO::CDBMLJOGGLO {
        if self.has_LHLMAIELHHE() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CDBMLJOGGLO::CDBMLJOGGLO::new()
        }
    }

    // .LALDKDDDHML IHHBCKOOECG = 1;

    pub fn IHHBCKOOECG(&self) -> &LALDKDDDHML {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(ref v)) => v,
            _ => <LALDKDDDHML as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_IHHBCKOOECG(&mut self) {
        self.EBCJPNHKDBP = ::std::option::Option::None;
    }

    pub fn has_IHHBCKOOECG(&self) -> bool {
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_IHHBCKOOECG(&mut self, v: LALDKDDDHML) {
        self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(v))
    }

    // Mutable pointer to the field.
    pub fn mut_IHHBCKOOECG(&mut self) -> &mut LALDKDDDHML {
        if let ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(_)) = self.EBCJPNHKDBP {
        } else {
            self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(LALDKDDDHML::new()));
        }
        match self.EBCJPNHKDBP {
            ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_IHHBCKOOECG(&mut self) -> LALDKDDDHML {
        if self.has_IHHBCKOOECG() {
            match self.EBCJPNHKDBP.take() {
                ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(v)) => v,
                _ => panic!(),
            }
        } else {
            LALDKDDDHML::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PKGJEALMBND",
            |m: &KNEIDNKFKEI| { &m.PKGJEALMBND },
            |m: &mut KNEIDNKFKEI| { &mut m.PKGJEALMBND },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::CFEAAIAKOJD::CFEAAIAKOJD>(
            "LHKCLKLGDLO",
            KNEIDNKFKEI::has_LHKCLKLGDLO,
            KNEIDNKFKEI::LHKCLKLGDLO,
            KNEIDNKFKEI::mut_LHKCLKLGDLO,
            KNEIDNKFKEI::set_LHKCLKLGDLO,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::IODAHNJLBFK::IODAHNJLBFK>(
            "FHLBKAKDAHL",
            KNEIDNKFKEI::has_FHLBKAKDAHL,
            KNEIDNKFKEI::FHLBKAKDAHL,
            KNEIDNKFKEI::mut_FHLBKAKDAHL,
            KNEIDNKFKEI::set_FHLBKAKDAHL,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FLFFNHBILPM::FLFFNHBILPM>(
            "AOCICHLHMIK",
            KNEIDNKFKEI::has_AOCICHLHMIK,
            KNEIDNKFKEI::AOCICHLHMIK,
            KNEIDNKFKEI::mut_AOCICHLHMIK,
            KNEIDNKFKEI::set_AOCICHLHMIK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::JGNHFHAELDP::JGNHFHAELDP>(
            "JKLMFJNPHPK",
            KNEIDNKFKEI::has_JKLMFJNPHPK,
            KNEIDNKFKEI::JKLMFJNPHPK,
            KNEIDNKFKEI::mut_JKLMFJNPHPK,
            KNEIDNKFKEI::set_JKLMFJNPHPK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NKHOPLIFDPI::NKHOPLIFDPI>(
            "shop_sync_info",
            KNEIDNKFKEI::has_shop_sync_info,
            KNEIDNKFKEI::shop_sync_info,
            KNEIDNKFKEI::mut_shop_sync_info,
            KNEIDNKFKEI::set_shop_sync_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LOOHAEDJAGK::LOOHAEDJAGK>(
            "HLEOICFJJOO",
            KNEIDNKFKEI::has_HLEOICFJJOO,
            KNEIDNKFKEI::HLEOICFJJOO,
            KNEIDNKFKEI::mut_HLEOICFJJOO,
            KNEIDNKFKEI::set_HLEOICFJJOO,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LKNOOLJPAGM::LKNOOLJPAGM>(
            "CCFIOBOBFLO",
            KNEIDNKFKEI::has_CCFIOBOBFLO,
            KNEIDNKFKEI::CCFIOBOBFLO,
            KNEIDNKFKEI::mut_CCFIOBOBFLO,
            KNEIDNKFKEI::set_CCFIOBOBFLO,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::CDBMLJOGGLO::CDBMLJOGGLO>(
            "LHLMAIELHHE",
            KNEIDNKFKEI::has_LHLMAIELHHE,
            KNEIDNKFKEI::LHLMAIELHHE,
            KNEIDNKFKEI::mut_LHLMAIELHHE,
            KNEIDNKFKEI::set_LHLMAIELHHE,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LALDKDDDHML>(
            "IHHBCKOOECG",
            KNEIDNKFKEI::has_IHHBCKOOECG,
            KNEIDNKFKEI::IHHBCKOOECG,
            KNEIDNKFKEI::mut_IHHBCKOOECG,
            KNEIDNKFKEI::set_IHHBCKOOECG,
        ));
        oneofs.push(kneidnkfkei::EBCJPNHKDBP::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KNEIDNKFKEI>(
            "KNEIDNKFKEI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KNEIDNKFKEI {
    const NAME: &'static str = "KNEIDNKFKEI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.PKGJEALMBND = is.read_uint32()?;
                },
                106 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(is.read_message()?));
                },
                90 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(is.read_message()?));
                },
                50 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(is.read_message()?));
                },
                122 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(is.read_message()?));
                },
                66 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(is.read_message()?));
                },
                82 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(is.read_message()?));
                },
                34 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(is.read_message()?));
                },
                114 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(is.read_message()?));
                },
                10 => {
                    self.EBCJPNHKDBP = ::std::option::Option::Some(kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.PKGJEALMBND != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.PKGJEALMBND);
        }
        if let ::std::option::Option::Some(ref v) = self.EBCJPNHKDBP {
            match v {
                &kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.PKGJEALMBND != 0 {
            os.write_uint32(7, self.PKGJEALMBND)?;
        }
        if let ::std::option::Option::Some(ref v) = self.EBCJPNHKDBP {
            match v {
                &kneidnkfkei::EBCJPNHKDBP::LHKCLKLGDLO(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &kneidnkfkei::EBCJPNHKDBP::FHLBKAKDAHL(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &kneidnkfkei::EBCJPNHKDBP::AOCICHLHMIK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &kneidnkfkei::EBCJPNHKDBP::JKLMFJNPHPK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &kneidnkfkei::EBCJPNHKDBP::ShopSyncInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &kneidnkfkei::EBCJPNHKDBP::HLEOICFJJOO(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &kneidnkfkei::EBCJPNHKDBP::CCFIOBOBFLO(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &kneidnkfkei::EBCJPNHKDBP::LHLMAIELHHE(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &kneidnkfkei::EBCJPNHKDBP::IHHBCKOOECG(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KNEIDNKFKEI {
        KNEIDNKFKEI::new()
    }

    fn clear(&mut self) {
        self.PKGJEALMBND = 0;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.EBCJPNHKDBP = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KNEIDNKFKEI {
        static instance: KNEIDNKFKEI = KNEIDNKFKEI {
            PKGJEALMBND: 0,
            EBCJPNHKDBP: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KNEIDNKFKEI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KNEIDNKFKEI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KNEIDNKFKEI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KNEIDNKFKEI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `KNEIDNKFKEI`
pub mod kneidnkfkei {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:KNEIDNKFKEI.EBCJPNHKDBP)
    pub enum EBCJPNHKDBP {
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.LHKCLKLGDLO)
        LHKCLKLGDLO(super::super::CFEAAIAKOJD::CFEAAIAKOJD),
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.FHLBKAKDAHL)
        FHLBKAKDAHL(super::super::IODAHNJLBFK::IODAHNJLBFK),
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.AOCICHLHMIK)
        AOCICHLHMIK(super::super::FLFFNHBILPM::FLFFNHBILPM),
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.JKLMFJNPHPK)
        JKLMFJNPHPK(super::super::JGNHFHAELDP::JGNHFHAELDP),
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.shop_sync_info)
        ShopSyncInfo(super::super::NKHOPLIFDPI::NKHOPLIFDPI),
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.HLEOICFJJOO)
        HLEOICFJJOO(super::super::LOOHAEDJAGK::LOOHAEDJAGK),
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.CCFIOBOBFLO)
        CCFIOBOBFLO(super::super::LKNOOLJPAGM::LKNOOLJPAGM),
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.LHLMAIELHHE)
        LHLMAIELHHE(super::super::CDBMLJOGGLO::CDBMLJOGGLO),
        // @@protoc_insertion_point(oneof_field:KNEIDNKFKEI.IHHBCKOOECG)
        IHHBCKOOECG(super::LALDKDDDHML),
    }

    impl ::protobuf::Oneof for EBCJPNHKDBP {
    }

    impl ::protobuf::OneofFull for EBCJPNHKDBP {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::KNEIDNKFKEI as ::protobuf::MessageFull>::descriptor().oneof_by_name("EBCJPNHKDBP").unwrap()).clone()
        }
    }

    impl EBCJPNHKDBP {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<EBCJPNHKDBP>("EBCJPNHKDBP")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dKNEIDNKFKEI_LALDKDDDHML.proto\x1a\x11CDBMLJOGGLO.proto\x1a\x11CFEA\
    AIAKOJD.proto\x1a\x11FLFFNHBILPM.proto\x1a\x11IODAHNJLBFK.proto\x1a\x11J\
    GNHFHAELDP.proto\x1a\x11LKNOOLJPAGM.proto\x1a\x11LOOHAEDJAGK.proto\x1a\
    \x11NKHOPLIFDPI.proto\"_\n\x0bLALDKDDDHML\x12.\n\x0bDHKIPLIFBEK\x18\x04\
    \x20\x03(\x0b2\x0c.KNEIDNKFKEIR\x0bDHKIPLIFBEK\x12\x20\n\x0bHGPAEBHKAHI\
    \x18\x02\x20\x01(\rR\x0bHGPAEBHKAHI\"\x84\x04\n\x0bKNEIDNKFKEI\x12\x20\n\
    \x0bPKGJEALMBND\x18\x07\x20\x01(\rR\x0bPKGJEALMBND\x120\n\x0bLHKCLKLGDLO\
    \x18\r\x20\x01(\x0b2\x0c.CFEAAIAKOJDH\0R\x0bLHKCLKLGDLO\x120\n\x0bFHLBKA\
    KDAHL\x18\x0b\x20\x01(\x0b2\x0c.IODAHNJLBFKH\0R\x0bFHLBKAKDAHL\x120\n\
    \x0bAOCICHLHMIK\x18\x06\x20\x01(\x0b2\x0c.FLFFNHBILPMH\0R\x0bAOCICHLHMIK\
    \x120\n\x0bJKLMFJNPHPK\x18\x0f\x20\x01(\x0b2\x0c.JGNHFHAELDPH\0R\x0bJKLM\
    FJNPHPK\x124\n\x0eshop_sync_info\x18\x08\x20\x01(\x0b2\x0c.NKHOPLIFDPIH\
    \0R\x0cshopSyncInfo\x120\n\x0bHLEOICFJJOO\x18\n\x20\x01(\x0b2\x0c.LOOHAE\
    DJAGKH\0R\x0bHLEOICFJJOO\x120\n\x0bCCFIOBOBFLO\x18\x04\x20\x01(\x0b2\x0c\
    .LKNOOLJPAGMH\0R\x0bCCFIOBOBFLO\x120\n\x0bLHLMAIELHHE\x18\x0e\x20\x01(\
    \x0b2\x0c.CDBMLJOGGLOH\0R\x0bLHLMAIELHHE\x120\n\x0bIHHBCKOOECG\x18\x01\
    \x20\x01(\x0b2\x0c.LALDKDDDHMLH\0R\x0bIHHBCKOOECGB\r\n\x0bEBCJPNHKDBPb\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(8);
            deps.push(super::CDBMLJOGGLO::file_descriptor().clone());
            deps.push(super::CFEAAIAKOJD::file_descriptor().clone());
            deps.push(super::FLFFNHBILPM::file_descriptor().clone());
            deps.push(super::IODAHNJLBFK::file_descriptor().clone());
            deps.push(super::JGNHFHAELDP::file_descriptor().clone());
            deps.push(super::LKNOOLJPAGM::file_descriptor().clone());
            deps.push(super::LOOHAEDJAGK::file_descriptor().clone());
            deps.push(super::NKHOPLIFDPI::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(2);
            messages.push(LALDKDDDHML::generated_message_descriptor_data());
            messages.push(KNEIDNKFKEI::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
