// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `BMDPJKOGJDM.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:BMDPJKOGJDM)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BMDPJKOGJDM {
    // message fields
    // @@protoc_insertion_point(field:BMDPJKOGJDM.script_id)
    pub script_id: u32,
    // @@protoc_insertion_point(field:BMDPJKOGJDM.MANCCCANCGF)
    pub MANCCCANCGF: u32,
    // message oneof groups
    pub MLOFIPBNFLL: ::std::option::Option<bmdpjkogjdm::MLOFIPBNFLL>,
    // special fields
    // @@protoc_insertion_point(special_field:BMDPJKOGJDM.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BMDPJKOGJDM {
    fn default() -> &'a BMDPJKOGJDM {
        <BMDPJKOGJDM as ::protobuf::Message>::default_instance()
    }
}

impl BMDPJKOGJDM {
    pub fn new() -> BMDPJKOGJDM {
        ::std::default::Default::default()
    }

    // .JBOGCOFOBDH DNCJAICOOLC = 8;

    pub fn DNCJAICOOLC(&self) -> &super::JBOGCOFOBDH::JBOGCOFOBDH {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(ref v)) => v,
            _ => <super::JBOGCOFOBDH::JBOGCOFOBDH as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_DNCJAICOOLC(&mut self) {
        self.MLOFIPBNFLL = ::std::option::Option::None;
    }

    pub fn has_DNCJAICOOLC(&self) -> bool {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_DNCJAICOOLC(&mut self, v: super::JBOGCOFOBDH::JBOGCOFOBDH) {
        self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(v))
    }

    // Mutable pointer to the field.
    pub fn mut_DNCJAICOOLC(&mut self) -> &mut super::JBOGCOFOBDH::JBOGCOFOBDH {
        if let ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(_)) = self.MLOFIPBNFLL {
        } else {
            self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(super::JBOGCOFOBDH::JBOGCOFOBDH::new()));
        }
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_DNCJAICOOLC(&mut self) -> super::JBOGCOFOBDH::JBOGCOFOBDH {
        if self.has_DNCJAICOOLC() {
            match self.MLOFIPBNFLL.take() {
                ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(v)) => v,
                _ => panic!(),
            }
        } else {
            super::JBOGCOFOBDH::JBOGCOFOBDH::new()
        }
    }

    // .OPMNJNKONOF PLLFLPPMKNH = 11;

    pub fn PLLFLPPMKNH(&self) -> &super::OPMNJNKONOF::OPMNJNKONOF {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(ref v)) => v,
            _ => <super::OPMNJNKONOF::OPMNJNKONOF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_PLLFLPPMKNH(&mut self) {
        self.MLOFIPBNFLL = ::std::option::Option::None;
    }

    pub fn has_PLLFLPPMKNH(&self) -> bool {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_PLLFLPPMKNH(&mut self, v: super::OPMNJNKONOF::OPMNJNKONOF) {
        self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_PLLFLPPMKNH(&mut self) -> &mut super::OPMNJNKONOF::OPMNJNKONOF {
        if let ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(_)) = self.MLOFIPBNFLL {
        } else {
            self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(super::OPMNJNKONOF::OPMNJNKONOF::new()));
        }
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_PLLFLPPMKNH(&mut self) -> super::OPMNJNKONOF::OPMNJNKONOF {
        if self.has_PLLFLPPMKNH() {
            match self.MLOFIPBNFLL.take() {
                ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(v)) => v,
                _ => panic!(),
            }
        } else {
            super::OPMNJNKONOF::OPMNJNKONOF::new()
        }
    }

    // .CFEDGDHPHID IAGOBMMLMEK = 13;

    pub fn IAGOBMMLMEK(&self) -> &super::CFEDGDHPHID::CFEDGDHPHID {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(ref v)) => v,
            _ => <super::CFEDGDHPHID::CFEDGDHPHID as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_IAGOBMMLMEK(&mut self) {
        self.MLOFIPBNFLL = ::std::option::Option::None;
    }

    pub fn has_IAGOBMMLMEK(&self) -> bool {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_IAGOBMMLMEK(&mut self, v: super::CFEDGDHPHID::CFEDGDHPHID) {
        self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_IAGOBMMLMEK(&mut self) -> &mut super::CFEDGDHPHID::CFEDGDHPHID {
        if let ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(_)) = self.MLOFIPBNFLL {
        } else {
            self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(super::CFEDGDHPHID::CFEDGDHPHID::new()));
        }
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_IAGOBMMLMEK(&mut self) -> super::CFEDGDHPHID::CFEDGDHPHID {
        if self.has_IAGOBMMLMEK() {
            match self.MLOFIPBNFLL.take() {
                ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CFEDGDHPHID::CFEDGDHPHID::new()
        }
    }

    // .COJGBHNABBA EBPOFJELAGB = 1;

    pub fn EBPOFJELAGB(&self) -> &super::COJGBHNABBA::COJGBHNABBA {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(ref v)) => v,
            _ => <super::COJGBHNABBA::COJGBHNABBA as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EBPOFJELAGB(&mut self) {
        self.MLOFIPBNFLL = ::std::option::Option::None;
    }

    pub fn has_EBPOFJELAGB(&self) -> bool {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EBPOFJELAGB(&mut self, v: super::COJGBHNABBA::COJGBHNABBA) {
        self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EBPOFJELAGB(&mut self) -> &mut super::COJGBHNABBA::COJGBHNABBA {
        if let ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(_)) = self.MLOFIPBNFLL {
        } else {
            self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(super::COJGBHNABBA::COJGBHNABBA::new()));
        }
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EBPOFJELAGB(&mut self) -> super::COJGBHNABBA::COJGBHNABBA {
        if self.has_EBPOFJELAGB() {
            match self.MLOFIPBNFLL.take() {
                ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(v)) => v,
                _ => panic!(),
            }
        } else {
            super::COJGBHNABBA::COJGBHNABBA::new()
        }
    }

    // .NDHMFFFNJMF EDNHECCAKAL = 5;

    pub fn EDNHECCAKAL(&self) -> &super::NDHMFFFNJMF::NDHMFFFNJMF {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(ref v)) => v,
            _ => <super::NDHMFFFNJMF::NDHMFFFNJMF as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_EDNHECCAKAL(&mut self) {
        self.MLOFIPBNFLL = ::std::option::Option::None;
    }

    pub fn has_EDNHECCAKAL(&self) -> bool {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_EDNHECCAKAL(&mut self, v: super::NDHMFFFNJMF::NDHMFFFNJMF) {
        self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(v))
    }

    // Mutable pointer to the field.
    pub fn mut_EDNHECCAKAL(&mut self) -> &mut super::NDHMFFFNJMF::NDHMFFFNJMF {
        if let ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(_)) = self.MLOFIPBNFLL {
        } else {
            self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(super::NDHMFFFNJMF::NDHMFFFNJMF::new()));
        }
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_EDNHECCAKAL(&mut self) -> super::NDHMFFFNJMF::NDHMFFFNJMF {
        if self.has_EDNHECCAKAL() {
            match self.MLOFIPBNFLL.take() {
                ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(v)) => v,
                _ => panic!(),
            }
        } else {
            super::NDHMFFFNJMF::NDHMFFFNJMF::new()
        }
    }

    // .OOOGLIAGKFC GOGOALNHACH = 4;

    pub fn GOGOALNHACH(&self) -> &super::OOOGLIAGKFC::OOOGLIAGKFC {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(ref v)) => v,
            _ => <super::OOOGLIAGKFC::OOOGLIAGKFC as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_GOGOALNHACH(&mut self) {
        self.MLOFIPBNFLL = ::std::option::Option::None;
    }

    pub fn has_GOGOALNHACH(&self) -> bool {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_GOGOALNHACH(&mut self, v: super::OOOGLIAGKFC::OOOGLIAGKFC) {
        self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(v))
    }

    // Mutable pointer to the field.
    pub fn mut_GOGOALNHACH(&mut self) -> &mut super::OOOGLIAGKFC::OOOGLIAGKFC {
        if let ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(_)) = self.MLOFIPBNFLL {
        } else {
            self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(super::OOOGLIAGKFC::OOOGLIAGKFC::new()));
        }
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_GOGOALNHACH(&mut self) -> super::OOOGLIAGKFC::OOOGLIAGKFC {
        if self.has_GOGOALNHACH() {
            match self.MLOFIPBNFLL.take() {
                ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(v)) => v,
                _ => panic!(),
            }
        } else {
            super::OOOGLIAGKFC::OOOGLIAGKFC::new()
        }
    }

    // .GIOJOOMHBDA JDLAAKGAJIK = 7;

    pub fn JDLAAKGAJIK(&self) -> &super::GIOJOOMHBDA::GIOJOOMHBDA {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(ref v)) => v,
            _ => <super::GIOJOOMHBDA::GIOJOOMHBDA as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_JDLAAKGAJIK(&mut self) {
        self.MLOFIPBNFLL = ::std::option::Option::None;
    }

    pub fn has_JDLAAKGAJIK(&self) -> bool {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_JDLAAKGAJIK(&mut self, v: super::GIOJOOMHBDA::GIOJOOMHBDA) {
        self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(v))
    }

    // Mutable pointer to the field.
    pub fn mut_JDLAAKGAJIK(&mut self) -> &mut super::GIOJOOMHBDA::GIOJOOMHBDA {
        if let ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(_)) = self.MLOFIPBNFLL {
        } else {
            self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(super::GIOJOOMHBDA::GIOJOOMHBDA::new()));
        }
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_JDLAAKGAJIK(&mut self) -> super::GIOJOOMHBDA::GIOJOOMHBDA {
        if self.has_JDLAAKGAJIK() {
            match self.MLOFIPBNFLL.take() {
                ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GIOJOOMHBDA::GIOJOOMHBDA::new()
        }
    }

    // uint32 KIMFNAOHLHM = 15;

    pub fn KIMFNAOHLHM(&self) -> u32 {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::KIMFNAOHLHM(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_KIMFNAOHLHM(&mut self) {
        self.MLOFIPBNFLL = ::std::option::Option::None;
    }

    pub fn has_KIMFNAOHLHM(&self) -> bool {
        match self.MLOFIPBNFLL {
            ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::KIMFNAOHLHM(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_KIMFNAOHLHM(&mut self, v: u32) {
        self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::KIMFNAOHLHM(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "script_id",
            |m: &BMDPJKOGJDM| { &m.script_id },
            |m: &mut BMDPJKOGJDM| { &mut m.script_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MANCCCANCGF",
            |m: &BMDPJKOGJDM| { &m.MANCCCANCGF },
            |m: &mut BMDPJKOGJDM| { &mut m.MANCCCANCGF },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::JBOGCOFOBDH::JBOGCOFOBDH>(
            "DNCJAICOOLC",
            BMDPJKOGJDM::has_DNCJAICOOLC,
            BMDPJKOGJDM::DNCJAICOOLC,
            BMDPJKOGJDM::mut_DNCJAICOOLC,
            BMDPJKOGJDM::set_DNCJAICOOLC,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::OPMNJNKONOF::OPMNJNKONOF>(
            "PLLFLPPMKNH",
            BMDPJKOGJDM::has_PLLFLPPMKNH,
            BMDPJKOGJDM::PLLFLPPMKNH,
            BMDPJKOGJDM::mut_PLLFLPPMKNH,
            BMDPJKOGJDM::set_PLLFLPPMKNH,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::CFEDGDHPHID::CFEDGDHPHID>(
            "IAGOBMMLMEK",
            BMDPJKOGJDM::has_IAGOBMMLMEK,
            BMDPJKOGJDM::IAGOBMMLMEK,
            BMDPJKOGJDM::mut_IAGOBMMLMEK,
            BMDPJKOGJDM::set_IAGOBMMLMEK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::COJGBHNABBA::COJGBHNABBA>(
            "EBPOFJELAGB",
            BMDPJKOGJDM::has_EBPOFJELAGB,
            BMDPJKOGJDM::EBPOFJELAGB,
            BMDPJKOGJDM::mut_EBPOFJELAGB,
            BMDPJKOGJDM::set_EBPOFJELAGB,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::NDHMFFFNJMF::NDHMFFFNJMF>(
            "EDNHECCAKAL",
            BMDPJKOGJDM::has_EDNHECCAKAL,
            BMDPJKOGJDM::EDNHECCAKAL,
            BMDPJKOGJDM::mut_EDNHECCAKAL,
            BMDPJKOGJDM::set_EDNHECCAKAL,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::OOOGLIAGKFC::OOOGLIAGKFC>(
            "GOGOALNHACH",
            BMDPJKOGJDM::has_GOGOALNHACH,
            BMDPJKOGJDM::GOGOALNHACH,
            BMDPJKOGJDM::mut_GOGOALNHACH,
            BMDPJKOGJDM::set_GOGOALNHACH,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::GIOJOOMHBDA::GIOJOOMHBDA>(
            "JDLAAKGAJIK",
            BMDPJKOGJDM::has_JDLAAKGAJIK,
            BMDPJKOGJDM::JDLAAKGAJIK,
            BMDPJKOGJDM::mut_JDLAAKGAJIK,
            BMDPJKOGJDM::set_JDLAAKGAJIK,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "KIMFNAOHLHM",
            BMDPJKOGJDM::has_KIMFNAOHLHM,
            BMDPJKOGJDM::KIMFNAOHLHM,
            BMDPJKOGJDM::set_KIMFNAOHLHM,
        ));
        oneofs.push(bmdpjkogjdm::MLOFIPBNFLL::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BMDPJKOGJDM>(
            "BMDPJKOGJDM",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BMDPJKOGJDM {
    const NAME: &'static str = "BMDPJKOGJDM";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                72 => {
                    self.script_id = is.read_uint32()?;
                },
                96 => {
                    self.MANCCCANCGF = is.read_uint32()?;
                },
                66 => {
                    self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(is.read_message()?));
                },
                90 => {
                    self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(is.read_message()?));
                },
                106 => {
                    self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(is.read_message()?));
                },
                10 => {
                    self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(is.read_message()?));
                },
                42 => {
                    self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(is.read_message()?));
                },
                34 => {
                    self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(is.read_message()?));
                },
                58 => {
                    self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(is.read_message()?));
                },
                120 => {
                    self.MLOFIPBNFLL = ::std::option::Option::Some(bmdpjkogjdm::MLOFIPBNFLL::KIMFNAOHLHM(is.read_uint32()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.script_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.script_id);
        }
        if self.MANCCCANCGF != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.MANCCCANCGF);
        }
        if let ::std::option::Option::Some(ref v) = self.MLOFIPBNFLL {
            match v {
                &bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::KIMFNAOHLHM(v) => {
                    my_size += ::protobuf::rt::uint32_size(15, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.script_id != 0 {
            os.write_uint32(9, self.script_id)?;
        }
        if self.MANCCCANCGF != 0 {
            os.write_uint32(12, self.MANCCCANCGF)?;
        }
        if let ::std::option::Option::Some(ref v) = self.MLOFIPBNFLL {
            match v {
                &bmdpjkogjdm::MLOFIPBNFLL::DNCJAICOOLC(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::PLLFLPPMKNH(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::IAGOBMMLMEK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::EBPOFJELAGB(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::EDNHECCAKAL(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::GOGOALNHACH(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::JDLAAKGAJIK(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &bmdpjkogjdm::MLOFIPBNFLL::KIMFNAOHLHM(v) => {
                    os.write_uint32(15, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BMDPJKOGJDM {
        BMDPJKOGJDM::new()
    }

    fn clear(&mut self) {
        self.script_id = 0;
        self.MANCCCANCGF = 0;
        self.MLOFIPBNFLL = ::std::option::Option::None;
        self.MLOFIPBNFLL = ::std::option::Option::None;
        self.MLOFIPBNFLL = ::std::option::Option::None;
        self.MLOFIPBNFLL = ::std::option::Option::None;
        self.MLOFIPBNFLL = ::std::option::Option::None;
        self.MLOFIPBNFLL = ::std::option::Option::None;
        self.MLOFIPBNFLL = ::std::option::Option::None;
        self.MLOFIPBNFLL = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BMDPJKOGJDM {
        static instance: BMDPJKOGJDM = BMDPJKOGJDM {
            script_id: 0,
            MANCCCANCGF: 0,
            MLOFIPBNFLL: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BMDPJKOGJDM {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BMDPJKOGJDM").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BMDPJKOGJDM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BMDPJKOGJDM {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BMDPJKOGJDM`
pub mod bmdpjkogjdm {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:BMDPJKOGJDM.MLOFIPBNFLL)
    pub enum MLOFIPBNFLL {
        // @@protoc_insertion_point(oneof_field:BMDPJKOGJDM.DNCJAICOOLC)
        DNCJAICOOLC(super::super::JBOGCOFOBDH::JBOGCOFOBDH),
        // @@protoc_insertion_point(oneof_field:BMDPJKOGJDM.PLLFLPPMKNH)
        PLLFLPPMKNH(super::super::OPMNJNKONOF::OPMNJNKONOF),
        // @@protoc_insertion_point(oneof_field:BMDPJKOGJDM.IAGOBMMLMEK)
        IAGOBMMLMEK(super::super::CFEDGDHPHID::CFEDGDHPHID),
        // @@protoc_insertion_point(oneof_field:BMDPJKOGJDM.EBPOFJELAGB)
        EBPOFJELAGB(super::super::COJGBHNABBA::COJGBHNABBA),
        // @@protoc_insertion_point(oneof_field:BMDPJKOGJDM.EDNHECCAKAL)
        EDNHECCAKAL(super::super::NDHMFFFNJMF::NDHMFFFNJMF),
        // @@protoc_insertion_point(oneof_field:BMDPJKOGJDM.GOGOALNHACH)
        GOGOALNHACH(super::super::OOOGLIAGKFC::OOOGLIAGKFC),
        // @@protoc_insertion_point(oneof_field:BMDPJKOGJDM.JDLAAKGAJIK)
        JDLAAKGAJIK(super::super::GIOJOOMHBDA::GIOJOOMHBDA),
        // @@protoc_insertion_point(oneof_field:BMDPJKOGJDM.KIMFNAOHLHM)
        KIMFNAOHLHM(u32),
    }

    impl ::protobuf::Oneof for MLOFIPBNFLL {
    }

    impl ::protobuf::OneofFull for MLOFIPBNFLL {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::BMDPJKOGJDM as ::protobuf::MessageFull>::descriptor().oneof_by_name("MLOFIPBNFLL").unwrap()).clone()
        }
    }

    impl MLOFIPBNFLL {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<MLOFIPBNFLL>("MLOFIPBNFLL")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11BMDPJKOGJDM.proto\x1a\x11CFEDGDHPHID.proto\x1a\x11COJGBHNABBA.prot\
    o\x1a\x11GIOJOOMHBDA.proto\x1a\x11JBOGCOFOBDH.proto\x1a\x11NDHMFFFNJMF.p\
    roto\x1a\x11OOOGLIAGKFC.proto\x1a\x11OPMNJNKONOF.proto\"\xdd\x03\n\x0bBM\
    DPJKOGJDM\x12\x1b\n\tscript_id\x18\t\x20\x01(\rR\x08scriptId\x12\x20\n\
    \x0bMANCCCANCGF\x18\x0c\x20\x01(\rR\x0bMANCCCANCGF\x120\n\x0bDNCJAICOOLC\
    \x18\x08\x20\x01(\x0b2\x0c.JBOGCOFOBDHH\0R\x0bDNCJAICOOLC\x120\n\x0bPLLF\
    LPPMKNH\x18\x0b\x20\x01(\x0b2\x0c.OPMNJNKONOFH\0R\x0bPLLFLPPMKNH\x120\n\
    \x0bIAGOBMMLMEK\x18\r\x20\x01(\x0b2\x0c.CFEDGDHPHIDH\0R\x0bIAGOBMMLMEK\
    \x120\n\x0bEBPOFJELAGB\x18\x01\x20\x01(\x0b2\x0c.COJGBHNABBAH\0R\x0bEBPO\
    FJELAGB\x120\n\x0bEDNHECCAKAL\x18\x05\x20\x01(\x0b2\x0c.NDHMFFFNJMFH\0R\
    \x0bEDNHECCAKAL\x120\n\x0bGOGOALNHACH\x18\x04\x20\x01(\x0b2\x0c.OOOGLIAG\
    KFCH\0R\x0bGOGOALNHACH\x120\n\x0bJDLAAKGAJIK\x18\x07\x20\x01(\x0b2\x0c.G\
    IOJOOMHBDAH\0R\x0bJDLAAKGAJIK\x12\"\n\x0bKIMFNAOHLHM\x18\x0f\x20\x01(\rH\
    \0R\x0bKIMFNAOHLHMB\r\n\x0bMLOFIPBNFLLb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(7);
            deps.push(super::CFEDGDHPHID::file_descriptor().clone());
            deps.push(super::COJGBHNABBA::file_descriptor().clone());
            deps.push(super::GIOJOOMHBDA::file_descriptor().clone());
            deps.push(super::JBOGCOFOBDH::file_descriptor().clone());
            deps.push(super::NDHMFFFNJMF::file_descriptor().clone());
            deps.push(super::OOOGLIAGKFC::file_descriptor().clone());
            deps.push(super::OPMNJNKONOF::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(BMDPJKOGJDM::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
